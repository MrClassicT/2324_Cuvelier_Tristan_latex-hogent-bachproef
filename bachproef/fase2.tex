%%=============================================================================
%% Fase 2: Technische analyse en experimenten
%%=============================================================================
\chapter{Technische Analyse en Experimenten}
\label{ch:fase2}

%%In deze fase was het doel om de lijst van gewenste functionele en niet-functionele requirements aan te vullen en deze te structureren naargelang hun prioriteit. Onder andere de keuze van de programmeertaal, eventuele libraries en andere softwaretools die gebruikt konden en zouden worden voor het maken en opzetten van de proof of concept werden hier gemaakt. De keuze van de programmeertaal werd bereikt door het opstellen van kleine prototypes in elke kandidaat-programmeertaal. Deze kregen werden dan getimed en daarnaast werden ook andere voor- en nadelen van elk bekeken om zo tot de beste optie te komen.

Net zoals bij alle software, was het ook hier van belang om eerst grondig onderzoek te doen naar wat er effectief nodig was en naar welke technologieën er best gebruikt konden worden.
Deze fase was van groot belang voor het verdere verloop van het project. Het was de bedoeling om een duidelijk beeld te krijgen van wat er nodig was en hoe dit het best kon worden aangepakt. Een duidelijk overzicht van de functionele en niet-functionele requirements was hierbij van groot belang. 

Als eerste werd er onderzocht wat een linter nu eigenlijk was en hoe deze werkte. Daarnaast werd er ook gekeken naar de verschillende soorten linters die er bestonden en naar de programmeertalen waarin deze gemaakt waren. Zodra duidelijk was wat er verwacht werd, werd er een lijst opgesteld van de gewenste functionele en niet-functionele requirements. Deze werden dan gestructureerd naargelang hun prioriteit zodat er bepaald kon worden wat er al dan niet tot de MVP zou behoren.

Met deze lijst kon er dan gekeken worden naar de keuze van de programmeertaal die gebruikt kon en zou worden voor het maken en opzetten van de proof of concept. De keuze van de programmeertaal werd bereikt door het opstellen van kleine prototypes in elke kandidaat-programmeertaal. Deze kregen werden dan getimed en daarnaast werden ook andere voor- en nadelen van elk bekeken om zo tot de beste optie te komen.

Uit de lijst van functionaliteiten werden er 2 gekozen die als eerste uitgewerkt zouden worden om zo een eerste versie van de linter te bekomen. Deze functionaliteiten waren: het detecteren van duplicaten en de detectie om te zien of alle required fields wel aanwezig waren.

\section{Linters onder de loep}
\label{sec:linters-onder-de-loep}

Gezien er tot op heden slechts één linter beschikbaar was voor BibLaTeX en deze niet optimaal leek te zijn, werd er besloten om ook eens te kijken naar andere linters die er bestonden. Zo kon er inspiratie opgedaan worden voor de proof of concept die gemaakt zou worden. Linters die werden bekeken zijn: Ruff, Pytype, Flake8, JSLint, Bibl en nog enkele andere. De linters diende net zoals het proof of concept open-source en gratis te gebruiken zijn.

\subsection{Ruff versus de concurrentie}
\label{subsec:ruff}
Ruff is een Python linter geschreven in Rust. Dat is ook direct waar Ruff zich onderscheid van de concurrent Python linters die gewoon in Python geschreven zijn. Rust is een programmeertaal die bekend staat om zeer snel en veilig te zijn. Dit zou dus duidelijk een goede keuze kunnen zijn voor een linter. Daarnaast is Rust ook veel lichter om te draaien op hardware dan Python, gezien Python een interpretatieve taal is en Rust een gecompileerde taal. Dit zou dus ook een goede keuze kunnen zijn voor een linter die in een CI-pipeline gebruikt zou worden. Ook is er slechts één versie van Rust waar steeds op verdergewerkt wordt, hierdoor wensen de developers van de Rust taal ook dat de code die in Rust geschreven wordt, steeds blijft werken. Of het nu over vijf jaar is, of over tien jaar, wat vandaag gecompileerd kan worden, zal ook binnen 10 jaar nog steeds gecompileerd kunnen worden. 

Ruff bleek op bepaalde taken tien tot wel honderd keer sneller te zijn! Dit was dan ook de reden waarom de Rust taal zeker als kandidaat werd beschouwd voor het maken van de linter.

\section{Keuze van de programmeertaal}
\subsection{Kandidaat-programmeertalen}
Om de gepaste programmeertaal te vinden, werden diverse kandidaat-programmeertalen overwogen. De kandidaat-programmeertalen waren: Rust, JavaScript en Python.
Deze lijst van programmeertalen zijn bekomen door enerzijds een lijst programmeertalen te bekijken en dan te

\subsubsection{Rust}
Rust leek dus duidelijk een grote kans te maken om de programmeertaal te worden waarin de linter geschreven zou worden, maar snelheid is niet de enige belangrijke factor. Ook kennis is van groot belang. Een taal kan nog zo snel zijn, als er niemand is die er mee kan werken, dan is het nutteloos. Rust is een taal die nog niet zo lang (sinds 2015) bestaat en waar nog niet zoveel mensen mee werken, ondanks de stijging in populariteit.

De leercurve was van groot belang gezien het doel was om een linter te maken die door zoveel mogelijk mensen gebruikt kon worden en vooraal ook uitgebreid kon worden achteraf.

\subsubsection{JavaScript}
Hoewel JavaScript een taal is die al veel langer bestaat en waar veel meer mensen mee werken, is het een taal die vooral gebruikt wordt voor webdevelopment en niet zozeer voor het maken van linters of andere pure scripts. Gezien het een gekende taal is, was het wel een optie om toch eens te overwegen.

\subsubsection{Python}
Python is een taal die al veel langer bestaat en waar veel mensen mee werken. Het is een taal die vooral gebruikt wordt voor scripts en andere kleine programma's. Het is een taal die zeer makkelijk te leren is en waar veel mensen mee werken. Dit was dan ook de reden waarom Python ook als kandidaat werd beschouwd voor het maken van de linter. Dit ook gezien de hoeveelheid aan linters die bestaan en in Python geschreven zijn.

\subsection{Keuze}
Na het opstellen van kleine prototypes in elke kandidaat-programmeertaal, werd er gekeken naar de voor- en nadelen van elk, alsook naar de uitvoeringstijd.
